<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>StompDonkey Disc Golf Association - Players</title>
 <link rel="stylesheet" href="styles.css">
 <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
 <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
 <header class="main-header">
 <button class="hamburger" aria-label="Toggle Menu">☰</button>
 <h1>StompDonkey Disc Golf Association</h1>
 </header>
 <nav class="sidebar" style="display: none;">
 <ul>
 <li><a href="index.html">Home</a></li>
 <li><a href="rounds.html">Rounds</a></li>
 <li><a href="records.html">Records</a></li>
 <li><a href="players.html">Players</a></li>
 </ul>
 </nav>
 <main>
 <section class="records-section">
 <h2>Player Profiles</h2>
 <div id="player-profiles" class="records-container"></div>
 </section>
 </main>
 <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
 <script>
 function parseCustomDate(dateStr) { const [datePart] = dateStr.split(' '); return new Date(datePart); }
 function isRoundComplete(row) { for (let i = 1; i <= 18; i++) if (parseInt(row[`Hole${i}`]) === 0 || isNaN(parseInt(row[`Hole${i}`]))) return false; return true; }
 fetch('data.csv').then(r => r.text()).then(csvText => {
 Papa.parse(csvText, { header: true, complete: function(results) {
 const data = results.data, players = ['ArmyGeddon', 'Jobby', 'Bucis', 'Miza'];
 const filteredData = data.filter(row => players.includes(row.PlayerName) && isRoundComplete(row));
 const playerData = {}; players.forEach(player => {
 playerData[player] = filteredData.filter(row => row.PlayerName === player).sort((a, b) => parseCustomDate(b.StartDate) - parseCustomDate(a.StartDate));
 });

 // Group data into rounds
 const roundMap = new Map();
 filteredData.forEach(row => {
 const key = `${row.StartDate}_${row.CourseName}`;
 if (!roundMap.has(key)) {
 const date = parseCustomDate(row.StartDate);
 roundMap.set(key, {
 startDate: row.StartDate,
 courseName: row.CourseName,
 year: date.getFullYear(),
 players: []
 });
 }
 roundMap.get(key).players.push({ player: row.PlayerName, total: parseInt(row.Total) });
 });
 const rounds = Array.from(roundMap.values());

 function computeHeadToHead(rounds) {
 const results = {};
 const players = ['ArmyGeddon', 'Jobby', 'Bucis', 'Miza'];
 players.forEach(p1 => {
 results[p1] = {};
 players.forEach(p2 => {
 if (p1 !== p2) results[p1][p2] = { wins: 0, draws: 0, losses: 0 };
 });
 });
 rounds.forEach(round => {
 const roundPlayers = round.players;
 if (roundPlayers.length < 2) return;
 for (let i = 0; i < roundPlayers.length; i++) {
 for (let j = i + 1; j < roundPlayers.length; j++) {
 const p1 = roundPlayers[i].player, p2 = roundPlayers[j].player;
 const total1 = roundPlayers[i].total, total2 = roundPlayers[j].total;
 if (total1 < total2) {
 results[p1][p2].wins++;
 results[p2][p1].losses++;
 } else if (total1 > total2) {
 results[p1][p2].losses++;
 results[p2][p1].wins++;
 } else {
 results[p1][p2].draws++;
 results[p2][p1].draws++;
 }
 }
 }
 });
 return results;
 }

 function calculateCurrentRating(rounds) {
 const last20 = rounds.slice(0, 20);
 const validRatings = last20.map(r => parseInt(r.RoundRating) || 0).filter(r => r > 0).sort((a, b) => b - a).slice(0, 8);
 return validRatings.length ? (validRatings.reduce((a, b) => a + b, 0) / validRatings.length).toFixed(2) : 'N/A';
 }
 function calculatePreviousRating(rounds) {
 const last20 = rounds.slice(0, 20);
 const validRatings = last20.map(r => parseInt(r.RoundRating) || 0).filter(r => r > 0).sort((a, b) => b - a).slice(1, 9);
 return validRatings.length ? (validRatings.reduce((a, b) => a + b, 0) / validRatings.length).toFixed(2) : 'N/A';
 }
 function getRatingMovement(current, previous) {
 if (current === 'N/A' || previous === 'N/A') return '';
 const diff = parseFloat(current) - parseFloat(previous);
 return diff > 0 ? `(+${diff.toFixed(2)})` : diff < 0 ? `(${diff.toFixed(2)})` : '(±0.00)';
 }
 function countAces(rounds) { let aceCount = 0; rounds.forEach(round => { for (let i = 1; i <= 18; i++) if (parseInt(round[`Hole${i}`]) === 1) aceCount++; }); return aceCount; }
 function getBestScoresPerCourse(rounds) {
 const bestScores = {}; rounds.forEach(round => {
 const course = round.CourseName, total = parseInt(round.Total), plusMinus = parseInt(round['+/-']), date = round.StartDate.split(' ')[0];
 if (!bestScores[course] || total < parseInt(bestScores[course].total)) bestScores[course] = { total, plusMinus, date };
 }); return bestScores;
 }
 function getJourneyOverview(rounds) {
 if (rounds.length === 0) return '';
 const firstRound = rounds[rounds.length - 1];
 const firstMonthYear = new Date(parseCustomDate(firstRound.StartDate)).toLocaleString('en-US', { month: 'long', year: 'numeric' });
 const validRatings = rounds.map(r => ({ rating: parseInt(r.RoundRating) || 0, ...r })).filter(r => r.rating > 0).sort((a, b) => parseCustomDate(a.StartDate) - parseCustomDate(b.StartDate));
 const earlyLow = validRatings.length ? validRatings[0] : null;
 const peak = validRatings.reduce((max, current) => max.rating > current.rating ? max : current, validRatings[0]);
 return `<p>Journey Overview: ArmyGeddon first appeared in ${firstMonthYear} and shows improvement. His RoundRating rose from ${earlyLow ? earlyLow.rating : 'N/A'} at ${earlyLow ? earlyLow.CourseName : 'N/A'} in ${earlyLow ? new Date(parseCustomDate(earlyLow.StartDate)).toLocaleString('en-US', { month: 'long', year: 'numeric' }) : 'N/A'} to ${peak.rating} (${peak['+/-'] > 0 ? '+' + peak['+/-'] : peak['+/-']}) at ${peak.CourseName} in ${new Date(parseCustomDate(peak.StartDate)).toLocaleString('en-US', { month: 'long', year: 'numeric' })}.</p>`;
 }

 const container = document.getElementById('player-profiles');
 const years = [...new Set(rounds.map(r => r.year))].sort();
 players.forEach((player, index) => {
 const rounds = playerData[player];
 if (rounds.length === 0) return;
 const totalRounds = rounds.length;
 const totalScores = rounds.map(r => parseInt(r.Total) || 0).filter(s => s > 0);
 const avgScore = totalScores.length ? (totalScores.reduce((a, b) => a + b, 0) / totalScores.length).toFixed(1) : 'N/A';
 const totalPlusMinus = rounds.map(r => parseInt(r['+/-']) || 0).reduce((a, b) => a + b, 0);
 const currentRating = calculateCurrentRating(rounds);
 const previousRating = calculatePreviousRating(rounds);
 const ratingMovement = getRatingMovement(parseFloat(currentRating) || 0, parseFloat(previousRating) || 0);
 const aceCount = countAces(rounds);
 const bestScores = getBestScoresPerCourse(rounds);
 const card = document.createElement('div');
 card.className = 'record-card player-profile'; card.style.animationDelay = `${index * 0.1}s`;
 const bestScoresHtml = Object.entries(bestScores).map(([course, data]) => `<li><strong>${course}</strong>: ${data.total} (+${data.plusMinus}) on ${data.date}</li>`).join('');
 let journeyOverview = ''; if (player === 'ArmyGeddon') journeyOverview = getJourneyOverview(rounds);
 // Aggregate data for less clutter (e.g., monthly averages)
 const roundDates = rounds.map(r => r.StartDate.split(' ')[0]);
 const roundRatings = rounds.map(r => parseInt(r.RoundRating) || null);
 const dateMap = new Map();
 rounds.forEach((round, i) => {
 const dateKey = round.StartDate.split(' ')[0].slice(0, 7); // Group by year-month
 if (!dateMap.has(dateKey)) dateMap.set(dateKey, { ratings: [], dates: [] });
 dateMap.get(dateKey).ratings.push(parseInt(round.RoundRating) || 0);
 dateMap.get(dateKey).dates.push(round.StartDate.split(' ')[0]);
 });
 const aggregatedDates = Array.from(dateMap.keys()).reverse(); // Reverse dates to run left to right
 const aggregatedRatings = aggregatedDates.map(key => {
 const values = dateMap.get(key).ratings.filter(r => r > 0);
 return values.length ? (values.reduce((a, b) => a + b, 0) / values.length).toFixed(2) : null;
 });
 const aggregatedMovingAvg = [];
 for (let i = 0; i < aggregatedRatings.length; i++) {
 const window = aggregatedRatings.slice(Math.max(0, i - 7), i + 1).filter(r => r !== null);
 aggregatedMovingAvg.push(window.length ? (window.reduce((a, b) => a + parseFloat(b), 0) / window.length).toFixed(2) : null);
 });
 card.innerHTML = `
 <h3>${player}</h3>
 <p><strong>Rounds Played:</strong> ${totalRounds}</p>
 <p><strong>Average Score:</strong> ${avgScore}</p>
 <p><strong>Best Scores by Course:</strong></p>
 <ul>${bestScoresHtml}</ul>
 <p><strong>Total +/-:</strong> ${totalPlusMinus}</p>
 <p><strong>Current Rating:</strong> ${currentRating} ${ratingMovement}</p>
 <p><strong>Ace Count:</strong> ${aceCount}</p>
 ${journeyOverview}
 <div class="chart-container">
 <canvas id="chart-${player.toLowerCase()}" class="player-chart"></canvas>
 </div>
 `;

 // Append head-to-head section
 const opponents = players.filter(p => p !== player);
 card.innerHTML += `
 <h4>Head-to-Head Records</h4>
 <select id="year-filter-${player}">
 <option value="all">All Years</option>
 ${years.map(year => `<option value="${year}">${year}</option>`).join('')}
 </select>
 <table>
 <thead>
 <tr>
 <th>Opponent</th>
 <th>Wins</th>
 <th>Draws</th>
 <th>Losses</th>
 </tr>
 </thead>
 <tbody id="head-to-head-${player}">
 ${opponents.map(opp => `
 <tr>
 <td>${opp}</td>
 <td id="wins-${player}-${opp}">0</td>
 <td id="draws-${player}-${opp}">0</td>
 <td id="losses-${player}-${opp}">0</td>
 </tr>
 `).join('')}
 </tbody>
 </table>
 `;

 container.appendChild(card);

 const ctx = document.getElementById(`chart-${player.toLowerCase()}`).getContext('2d');
 const chart = new Chart(ctx, {
 type: 'line',
 data: { 
 labels: aggregatedDates,
 datasets: [
 { 
 label: 'Round Rating', 
 data: aggregatedRatings, 
 borderColor: 'rgba(54, 162, 235, 1)', 
 backgroundColor: 'rgba(54, 162, 235, 0.2)', 
 fill: false, 
 tension: 0.1, 
 pointRadius: 3, 
 pointHoverRadius: 5 
 },
 { 
 label: 'Moving Average Rating (8 rounds)', 
 data: aggregatedMovingAvg, 
 borderColor: 'rgba(255, 159, 64, 1)', 
 backgroundColor: 'rgba(255, 159, 64, 0.2)', 
 fill: false, 
 borderWidth: 2, 
 tension: 0.1, 
 pointRadius: 0 
 }
 ]
 },
 options: {
 responsive: true,
 maintainAspectRatio: false,
 scales: { 
 x: { 
 title: { display: true, text: 'Date', color: '#2e2e2e', font: { family: 'Oswald', size: 14 } }, 
 ticks: { color: '#2e2e2e', maxRotation: 45, minRotation: 45 } 
 }, 
 y: { 
 title: { display: true, text: 'Rating', color: '#2e2e2e', font: { family: 'Oswald', size: 14 } }, 
 beginAtZero: false, 
 min: 90, 
 max: 210, 
 ticks: { color: '#2e2e2e' } 
 }
 },
 plugins: {
 legend: { 
 position: 'top', 
 labels: { 
 color: '#2e2e2e', 
 font: { family: 'Oswald', size: 12 }, 
 usePointStyle: false, // Use line style instead of box
 generateLabels: function(chart) {
 const datasets = chart.data.datasets;
 return datasets.map((dataset, i) => ({
 text: dataset.label,
 fillStyle: dataset.backgroundColor,
 strokeStyle: dataset.borderColor,
 lineWidth: dataset.borderWidth || 1,
 datasetIndex: i
 }));
 }
 }
 },
 tooltip: { 
 enabled: false,
 external: function(context) {
 const tooltip = context.tooltip;
 if (tooltip.opacity === 0) return;
 const index = tooltip.dataPoints[0].dataIndex;
 const dateKey = aggregatedDates[index];
 const round = rounds.find(r => r.StartDate.split(' ')[0].slice(0, 7) === dateKey);
 let tooltipEl = document.getElementById('chartjs-tooltip');
 if (!tooltipEl) {
 tooltipEl = document.createElement('div');
 tooltipEl.id = 'chartjs-tooltip';
 tooltipEl.style.position = 'absolute';
 tooltipEl.style.background = 'rgba(0, 0, 0, 0.8)';
 tooltipEl.style.color = '#fff';
 tooltipEl.style.padding = '5px 10px';
 tooltipEl.style.borderRadius = '3px';
 document.body.appendChild(tooltipEl);
 }
 if (round) {
 const content = `
 <strong>Date:</strong> ${round.StartDate.split(' ')[0]}<br>
 <strong>Score:</strong> ${round.Total}<br>
 <strong>+/-:</strong> ${round['+/-'] >= 0 ? '+' + round['+/-'] : round['+/-']}<br>
 <strong>Rating:</strong> ${round.RoundRating || 'N/A'}<br>
 <strong>Course:</strong> ${round.CourseName}
 `;
 tooltipEl.innerHTML = content;
 }
 const pos = context.chart.canvas.getBoundingClientRect();
 tooltipEl.style.left = pos.left + tooltip.caretX + 'px';
 tooltipEl.style.top = pos.top + tooltip.caretY + 'px';
 tooltipEl.style.opacity = 1;
 }
 },
 zoom: { zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy' }, pan: { enabled: true, mode: 'xy' } }
 },
 onClick: (event, elements) => {
 if (elements.length > 0) {
 const index = elements[0].index;
 chart.tooltip.setActiveElements([{ datasetIndex: 0, index }], { x: event.x, y: event.y });
 chart.update();
 }
 }
 }
 });
 // Hide tooltip on mouseup/touchend
 const canvas = document.getElementById(`chart-${player.toLowerCase()}`);
 canvas.addEventListener('mouseup', () => { chart.tooltip.setActiveElements([], { x: 0, y: 0 }); chart.update(); });
 canvas.addEventListener('touchend', () => { chart.tooltip.setActiveElements([], { x: 0, y: 0 }); chart.update(); });

 // Add year filter event listener
 const yearFilter = document.getElementById(`year-filter-${player}`);
 yearFilter.addEventListener('change', () => {
 const selectedYear = yearFilter.value;
 let filteredRounds = selectedYear === 'all' ? rounds : rounds.filter(r => r.year == selectedYear);
 const headToHead = computeHeadToHead(filteredRounds);
 opponents.forEach(opp => {
 const winsEl = document.getElementById(`wins-${player}-${opp}`);
 const drawsEl = document.getElementById(`draws-${player}-${opp}`);
 const lossesEl = document.getElementById(`losses-${player}-${opp}`);
 const record = headToHead[player][opp];
 winsEl.textContent = record.wins;
 drawsEl.textContent = record.draws;
 lossesEl.textContent = record.losses;
 });
 });

 // Initialize to "All Years"
 yearFilter.value = 'all';
 yearFilter.dispatchEvent(new Event('change'));
 });
 } });
 }).catch(error => console.error('Error fetching CSV:', error));
 document.querySelector('.hamburger').addEventListener('click', () => {
 const sidebar = document.querySelector('.sidebar');
 sidebar.style.display = sidebar.style.display === 'none' ? 'block' : 'none';
 });
 </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​