<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>StompDonkey Disc Golf Association - Players</title>
 <link rel="stylesheet" href="styles.css">
 <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;600&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
 <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
 <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
</head>
<body>
 <header class="main-header">
 <button class="hamburger" aria-label="Toggle Menu">☰</button>
 <h1>StompDonkey Disc Golf Association</h1>
 </header>
 <nav class="sidebar" style="display: none;">
 <ul>
 <li><a href="index.html">Home</a></li>
 <li><a href="rounds.html">Rounds</a></li>
 <li><a href="records.html">Records</a></li>
 <li><a href="players.html">Players</a></li>
 </ul>
 </nav>
 <main>
 <section class="records-section">
 <h2>Player Profiles</h2>
 <div id="player-profiles" class="records-container"></div>
 </section>
 </main>
 <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.0/papaparse.min.js"></script>
 <script>
 console.log('Script started');

 function parseCustomDate(dateStr) {
 console.log('Parsing date:', dateStr);
 const [datePart] = dateStr.split(' ');
 return new Date(datePart);
 }

 function isRoundComplete(row) {
 for (let i = 1; i <= 18; i++) {
 const holeScore = parseInt(row[`Hole${i}`]);
 if (holeScore === 0 || isNaN(holeScore)) {
 console.log(`Incomplete round for ${row.PlayerName}: Hole${i} = ${row[`Hole${i}`]}`);
 return false;
 }
 }
 return true;
 }

 fetch('data.csv')
 .then(r => {
 if (!r.ok) throw new Error(`Fetch failed: ${r.status}`);
 console.log('Fetch successful');
 return r.text();
 })
 .then(csvText => {
 console.log('CSV text received:', csvText.substring(0, 100));
 Papa.parse(csvText, {
 header: true,
 complete: function(results) {
 console.log('Parsed data:', results.data);
 console.log('Errors:', results.errors);
 const data = results.data;
 const players = ['ArmyGeddon', 'Jobby', 'Bucis', 'Miza'];
 console.log('Filtering data for players:', players);
 const filteredData = data.filter(row => {
 const included = players.includes(row.PlayerName) && isRoundComplete(row);
 if (!included) console.log('Filtered out:', row);
 return included;
 });
 console.log('Filtered data:', filteredData);

 if (filteredData.length === 0) {
 console.error('No valid data after filtering');
 document.getElementById('player-profiles').innerHTML = '<p>No valid player data found.</p>';
 return;
 }

 const playerData = {};
 players.forEach(player => {
 playerData[player] = filteredData.filter(row => row.PlayerName === player)
 .sort((a, b) => parseCustomDate(b.StartDate) - parseCustomDate(a.StartDate));
 console.log(`Rounds for ${player}:`, playerData[player].length);
 });

 // Head-to-head stats
 const headToHead = {};
 players.forEach(player => {
 headToHead[player] = {};
 players.forEach(opponent => {
 if (opponent !== player) {
 headToHead[player][opponent] = { wins: 0, draws: 0, losses: 0 };
 }
 });
 });
 const matches = {};
 filteredData.forEach(round => {
 const date = round.StartDate.split(' ')[0];
 if (!matches[date]) matches[date] = [];
 matches[date].push({ player: round.PlayerName, total: parseInt(round.Total) });
 });
 Object.values(matches).forEach(match => {
 const playersInMatch = match.map(entry => entry.player);
 for (let i = 0; i < playersInMatch.length; i++) {
 for (let j = i + 1; j < playersInMatch.length; j++) {
 const playerA = playersInMatch[i];
 const playerB = playersInMatch[j];
 const scoreA = match.find(entry => entry.player === playerA).total;
 const scoreB = match.find(entry => entry.player === playerB).total;
 if (scoreA < scoreB) {
 headToHead[playerA][playerB].wins++;
 headToHead[playerB][playerA].losses++;
 } else if (scoreA > scoreB) {
 headToHead[playerA][playerB].losses++;
 headToHead[playerB][playerA].wins++;
 } else {
 headToHead[playerA][playerB].draws++;
 headToHead[playerB][playerA].draws++;
 }
 }
 }
 });
 console.log('Head-to-head stats:', headToHead);

 // Rest of the functions remain unchanged (omitted for brevity)
 function calculateCurrentRating(rounds) { /* ... */ }
 function calculatePreviousRating(rounds) { /* ... */ }
 function getRatingMovement(current, previous) { /* ... */ }
 function countAces(rounds) { /* ... */ }
 function getBestScoresPerCourse(rounds) { /* ... */ }
 function getJourneyOverview(rounds) { /* ... */ }

 const container = document.getElementById('player-profiles');
 players.forEach((player, index) => {
 const rounds = playerData[player];
 if (rounds.length === 0) {
 console.log(`No rounds for ${player}, skipping`);
 return;
 }
 const card = document.createElement('div');
 card.className = 'record-card player-profile';
 card.style.animationDelay = `${index * 0.1}s`;
 card.innerHTML = `<h3>${player}</h3><p>Loading data...</p>`; // Placeholder
 container.appendChild(card);
 console.log(`Added card for ${player}`);
 });
 }
 });
 })
 .catch(error => console.error('Error:', error));

 document.querySelector('.hamburger').addEventListener('click', () => {
 const sidebar = document.querySelector('.sidebar');
 sidebar.style.display = sidebar.style.display === 'none' ? 'block' : 'none';
 });
 </script>
</body>
</html>
​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
